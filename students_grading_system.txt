# =====================================================
# JKUAT STUDENT GRADING SYSTEM - FULL FINAL VERSION
# =====================================================

import tkinter as tk
from tkinter import ttk, messagebox
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas

# ---------------------------
# DATABASE
# ---------------------------
conn = sqlite3.connect("students.db")
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS students (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    course TEXT,
    year TEXT,
    semester TEXT,
    average REAL,
    grade TEXT,
    gpa REAL,
    classification TEXT
)
""")
conn.commit()

# ---------------------------
# MAIN WINDOW
# ---------------------------
root = tk.Tk()
root.title("JKUAT Student Grading System")
root.geometry("1400x900")
root.configure(bg="#f0f4f7")  # background color

students = []
unit_entries = {}
student_unit_marks = {}  # store per-unit marks keyed by student ID
selected_student_id = None

# ---------------------------
# GRADE & GPA FUNCTIONS
# ---------------------------


def grade(mark):
    if mark >= 70:
        return "A"
    elif mark >= 60:
        return "B"
    elif mark >= 50:
        return "C"
    elif mark >= 40:
        return "D"
    else:
        return "F"


def mark_to_point(mark):
    if mark >= 70:
        return 5.0
    elif mark >= 60:
        return 4.0
    elif mark >= 50:
        return 3.0
    elif mark >= 40:
        return 2.0
    else:
        return 0.0


def classify_gpa(gpa):
    if gpa >= 4.5:
        return "First Class"
    elif gpa >= 3.5:
        return "Second Class Upper"
    elif gpa >= 2.5:
        return "Second Class Lower"
    elif gpa >= 2.0:
        return "Pass"
    else:
        return "Fail"


# ---------------------------
# UNITS BY YEAR & SEMESTER
# ---------------------------
units_by_year_semester = {
    ("Year 1", "Semester 1"): {"HRD 2101": "Communication Skills", "SMA 2104": "Mathematics for Science", "SMA 2100": "Discrete Mathematics", "STA 2104": "Calculus I", "STA 2100": "Probability I", "STA 2102": "IT for Statistics", "HBC 2107": "Intro Microâ€‘Economics"},
    ("Year 1", "Semester 2"): {"HRD 2102": "Development Studies & Ethics", "SZL 2111": "HIV/AIDS", "STA 2105": "Calculus II", "STA 2101": "Algebra for Stats & Finance", "STA 2106": "Business Economics II", "STA 2107": "Database Management", "STA 2191": "Financial Mathematics I"},
    ("Year 2", "Semester 1"): {"SMA 2201": "Linear Algebra II", "STA 2200": "Probability II", "STA 2202": "Computer Interactive Stats", "STA 2204": "Calculus III", "STA 2291": "Actuarial Maths I", "STA 2209": "Operations Research", "STA 2290": "Financial Maths II"},
    ("Year 2", "Semester 2"): {"SMA 2231": "Differential Equations", "STA 2201": "Probability III", "STA 2205": "Statistical Programming", "STA 2209": "Operations Research Methods", "STA 2292": "Actuarial Maths II", "STA 2294": "Financial Economics I"},
    ("Year 3", "Semester 1"): {"STA 2300": "Theory of Estimation", "STA 2302": "Probability IV", "SMA 2306": "Real Analysis", "STA 2311": "Statistical Programming II", "STA 2413": "Regression Modelling I", "STA 2390": "Actuarial Maths III", "STA 2470": "Operations Research Modelling"},
    ("Year 3", "Semester 2"): {"HRD 2114": "Research Methodology", "STA 2301": "Tests of Hypotheses", "STA 2309": "Risk Theory for Actuarial Science", "STA 2391": "Stochastic Processes", "STA 2401": "Time Series Analysis", "STA 2395": "Decision Theory & Bayesian I", "STA 2422": "Game Theory"},
    ("Year 4", "Semester 1"): {"HRD 2401": "Entrepreneurship Skills", "HRD 2402": "Financial Reporting & Accounts", "HRD 2403": "Pensions & Retirement Benefits", "STA 2442": "Financial Economics for Actuarial Science", "STA 2490": "Demographic Techniques", "STA 2491": "Actuarial Maths IV", "STA 2498": "Bayesian Inference II", "STA 2402": "Design & Analysis of Sample Surveys", "STA 2494": "Actuarial Science Project"},
    ("Year 4", "Semester 2"): {"HRD 2301": "Life Assurance Theory", "STA 2420": "Financial Time Series", "STA 2423": "Financial Risk Management", "STA 2492": "Credibility Theory & Loss Models", "STA 2493": "Survival Analysis", "STA 2495": "Non-Life Insurance Mathematics", "HRD 2404": "Investment & Asset Management", "STA 2416": "Computer Intensive Stats", "STA 2494": "Actuarial Science Project (Cont.)"},
    ("Year 4", "Semester 3"): {"STA 2496": "Industrial Attachment / Project"}
}

# ---------------------------
# INPUT FIELDS
# ---------------------------
tk.Label(root, text="Student Name", bg="#f0f4f7").grid(
    row=0, column=0, sticky="w")
name_entry = tk.Entry(root, width=30)
name_entry.grid(row=0, column=1)

tk.Label(root, text="Course", bg="#f0f4f7").grid(row=1, column=0, sticky="w")
course_var = tk.StringVar()
course_combo = ttk.Combobox(root, textvariable=course_var,
                            values=["Biostatistics", "Statistics", "Actuarial Science",
                                    "Operational Research", "Financial Engineering"],
                            state="readonly", width=28)
course_combo.grid(row=1, column=1)
course_combo.current(0)

tk.Label(root, text="Year", bg="#f0f4f7").grid(row=2, column=0, sticky="w")
year_var = tk.StringVar()
year_combo = ttk.Combobox(root, textvariable=year_var, values=[
                          "Year 1", "Year 2", "Year 3", "Year 4"], state="readonly", width=28)
year_combo.grid(row=2, column=1)
year_combo.current(0)

tk.Label(root, text="Semester", bg="#f0f4f7").grid(row=3, column=0, sticky="w")
semester_var = tk.StringVar()
semester_combo = ttk.Combobox(root, textvariable=semester_var, values=[
                              "Semester 1", "Semester 2", "Semester 3"], state="readonly", width=28)
semester_combo.grid(row=3, column=1)
semester_combo.current(0)

# ---------------------------
# UNITS FRAME
# ---------------------------
units_frame = tk.Frame(root, bg="#f0f4f7")
units_frame.grid(row=5, column=0, columnspan=2, pady=10, sticky="w")


def load_units(*args):
    for w in units_frame.winfo_children():
        w.destroy()
    unit_entries.clear()
    key = (year_var.get(), semester_var.get())
    if key not in units_by_year_semester:
        return
    row = 0
    for code, name in units_by_year_semester[key].items():
        tk.Label(units_frame, text=f"{name} ({code})", bg="#f0f4f7").grid(
            row=row, column=0, sticky="w")
        e = tk.Entry(units_frame, width=10)
        e.grid(row=row, column=1)
        unit_entries[code] = e
        row += 1


year_combo.bind("<<ComboboxSelected>>", load_units)
semester_combo.bind("<<ComboboxSelected>>", load_units)
root.after(200, load_units)

# ---------------------------
# TREEVIEW TABLE
# ---------------------------
cols = ("Name", "Course", "Year", "Semester",
        "Average", "Grade", "GPA", "Classification")
tree = ttk.Treeview(root, columns=cols, show="headings", height=12)
for c in cols:
    tree.heading(c, text=c)
    tree.column(c, width=150)
tree.grid(row=20, column=0, columnspan=5, pady=10)

# Styling
style = ttk.Style()
style.theme_use("clam")
style.configure("Treeview.Heading", background="#004080",
                foreground="white", font=("Helvetica", 12, "bold"))
style.configure("Treeview", background="white",
                foreground="black", rowheight=25, fieldbackground="white")
tree.tag_configure('oddrow', background="#e6f2ff")
tree.tag_configure('evenrow', background="white")


def color_rows():
    for i, row in enumerate(tree.get_children()):
        tree.item(row, tags=('oddrow',) if i % 2 else ('evenrow',))


root.after(500, color_rows)

# ---------------------------
# CRUD FUNCTIONS
# ---------------------------


def load_from_db():
    students.clear()
    tree.delete(*tree.get_children())
    for row in cursor.execute("SELECT * FROM students"):
        students.append(row)
        tree.insert("", "end", values=row[1:])
    color_rows()


def submit_student():
    marks_dict = {}
    for code, entry in unit_entries.items():
        if entry.get() == "":
            messagebox.showerror("Error", "All marks required")
            return
        marks_dict[code] = float(entry.get())
    marks_list = list(marks_dict.values())
    avg = sum(marks_list)/len(marks_list)
    g = grade(avg)
    gpa = sum([mark_to_point(m) for m in marks_list])/len(marks_list)
    classification = classify_gpa(gpa)

    cursor.execute(
        "INSERT INTO students(name,course,year,semester,average,grade,gpa,classification) VALUES(?,?,?,?,?,?,?,?)",
        (name_entry.get(), course_var.get(), year_var.get(),
         semester_var.get(), avg, g, gpa, classification)
    )
    conn.commit()
    student_id = cursor.lastrowid
    student_unit_marks[student_id] = marks_dict
    load_from_db()
    messagebox.showinfo("Saved", "Student added")


def load_for_edit():
    global selected_student_id
    sel = tree.selection()
    if not sel:
        messagebox.showerror("Select", "Select a student")
        return
    index = tree.index(sel[0])
    student = students[index]
    selected_student_id = student[0]
    name_entry.delete(0, tk.END)
    name_entry.insert(0, student[1])
    course_var.set(student[2])
    year_var.set(student[3])
    semester_var.set(student[4])
    load_units()
    marks = student_unit_marks.get(selected_student_id, {})
    for code, mark in marks.items():
        if code in unit_entries:
            unit_entries[code].delete(0, tk.END)
            unit_entries[code].insert(0, str(mark))


def update_student():
    global selected_student_id
    if not selected_student_id:
        messagebox.showerror("Error", "Load student first")
        return
    marks_dict = {}
    for code, entry in unit_entries.items():
        if entry.get() == "":
            messagebox.showerror("Error", "All marks required")
            return
        marks_dict[code] = float(entry.get())
    marks_list = list(marks_dict.values())
    avg = sum(marks_list)/len(marks_list)
    g = grade(avg)
    gpa = sum([mark_to_point(m) for m in marks_list])/len(marks_list)
    classification = classify_gpa(gpa)

    cursor.execute(
        "UPDATE students SET name=?,course=?,year=?,semester=?,average=?,grade=?,gpa=?,classification=? WHERE id=?",
        (name_entry.get(), course_var.get(), year_var.get(),
         semester_var.get(), avg, g, gpa, classification, selected_student_id)
    )
    conn.commit()
    student_unit_marks[selected_student_id] = marks_dict
    load_from_db()
    messagebox.showinfo("Updated", "Student updated")


def delete_student():
    sel = tree.selection()
    if not sel:
        return
    index = tree.index(sel[0])
    student_id = students[index][0]
    cursor.execute("DELETE FROM students WHERE id=?", (student_id,))
    conn.commit()
    if student_id in student_unit_marks:
        del student_unit_marks[student_id]
    load_from_db()

# ---------------------------
# DASHBOARD
# ---------------------------


def show_dashboard():
    df = pd.read_sql_query("SELECT * FROM students", conn)
    if df.empty:
        messagebox.showerror("No Data", "No student data")
        return
    df.groupby("course")["average"].mean().plot(
        kind="bar", title="Average per Course")
    plt.show()
    df.groupby("year")["average"].mean().plot(
        kind="bar", title="Average per Year")
    plt.show()
    df.groupby("semester")["average"].mean().plot(
        kind="bar", title="Average per Semester")
    plt.show()
    df["grade"].value_counts().plot(
        kind="pie", autopct="%1.1f%%", title="Grade Distribution")
    plt.show()
    df.sort_values("average", ascending=False).head(10).plot(
        x="name", y="average", kind="bar", title="Top 10 Students")
    plt.show()
    df.groupby("classification")["average"].mean().plot(
        kind="bar", title="Average per Classification")
    plt.show()

# ---------------------------
# EXPORT FUNCTIONS
# ---------------------------


def export_excel():
    df = pd.read_sql_query("SELECT * FROM students", conn)
    if df.empty:
        messagebox.showerror("No Data", "No student data to export")
        return
    df.to_excel("students.xlsx", index=False)
    messagebox.showinfo(
        "Exported", "Student records exported to students.xlsx")


def export_pdf():
    sel = tree.selection()
    if not sel:
        messagebox.showerror("Select", "Select a student")
        return
    index = tree.index(sel[0])
    student = students[index]
    key = (student[3], student[4])
    c = canvas.Canvas(f"{student[1]}_transcript.pdf", pagesize=letter)
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, 780, "JKUAT Student Transcript")
    c.setFont("Helvetica", 12)
    c.drawString(50, 750, f"Student Name: {student[1]}")
    c.drawString(50, 730, f"Course: {student[2]}")
    c.drawString(50, 710, f"Year: {student[3]}")
    c.drawString(50, 690, f"Semester: {student[4]}")
    c.drawString(50, 670, f"Average: {round(student[5], 2)}")
    c.drawString(50, 650, f"Grade: {student[6]}")
    c.drawString(50, 630, f"GPA: {round(student[7], 2)}")
    c.drawString(50, 610, f"Classification: {student[8]}")
    # Per-unit marks
    y = 590
    marks_dict = student_unit_marks.get(student[0], {})
    if key in units_by_year_semester:
        c.setFont("Helvetica-Bold", 12)
        c.drawString(50, y, "Unit Marks:")
        y -= 20
        c.setFont("Helvetica", 12)
        for code, name in units_by_year_semester[key].items():
            mark_val = marks_dict.get(code, "N/A")
            c.drawString(50, y, f"{code} - {name}: {mark_val}")
            y -= 20
            if y < 50:
                c.showPage()
                y = 750
    c.save()
    messagebox.showinfo(
        "Exported", f"Transcript exported to {student[1]}_transcript.pdf")


# ---------------------------
# BUTTONS
# ---------------------------
btn_frame = tk.Frame(root, bg="#f0f4f7")
btn_frame.grid(row=19, column=0, columnspan=7, pady=10)

button_colors = {"bg": "#004080", "fg": "white",
                 "activebackground": "#3399ff", "activeforeground": "white"}

tk.Button(btn_frame, text="Add Student", width=14,
          command=submit_student, **button_colors).grid(row=0, column=0, padx=5)
tk.Button(btn_frame, text="Load for Edit", width=14,
          command=load_for_edit, **button_colors).grid(row=0, column=1, padx=5)
tk.Button(btn_frame, text="Update Student", width=14,
          command=update_student, **button_colors).grid(row=0, column=2, padx=5)
tk.Button(btn_frame, text="Delete Student", width=14,
          command=delete_student, **button_colors).grid(row=0, column=3, padx=5)
tk.Button(btn_frame, text="Dashboard", width=14, command=show_dashboard,
          **button_colors).grid(row=0, column=4, padx=5)
tk.Button(btn_frame, text="Export Excel", width=14,
          command=export_excel, **button_colors).grid(row=0, column=5, padx=5)
tk.Button(btn_frame, text="Export PDF", width=14, command=export_pdf,
          **button_colors).grid(row=0, column=6, padx=5)

# ---------------------------
# INITIAL LOAD
# ---------------------------
load_from_db()
root.mainloop()
